<!DOCTYPE html>
<html class="dark" lang="en">
<head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>JSON Toolbox</title>
        <!-- Tailwind CSS v3 with plugins -->
        <script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-bw3nHkZGVbFZN7R6pujISiFDUFxIr05oig3NbS1Ry6j3Tz7kRXKuX3sI5OGucs5cjox96D65gis6pZeTuY4Ykg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
        <style>
            :root {
                --card-bg: #0f172a;
                --editor-bg: #0b1021;
                --text-primary: #e2e8f0;
                --text-muted: #94a3b8;
                --accent: #8b5cf6;
                --accent-2: #22c55e;
            }

            body {
                background: radial-gradient(circle at 20% 20%, rgba(139, 92, 246, 0.3), transparent 35%),
                            radial-gradient(circle at 80% 0%, rgba(34, 197, 235, 0.25), transparent 30%),
                            #0b1021;
                color: var(--text-primary);
                font-family: 'Inter', system-ui, -apple-system, 'Segoe UI', sans-serif;
                min-height: 100vh;
            }

            .ambient-glow {
                position: absolute;
                inset: 0;
                background: radial-gradient(circle at 30% 20%, rgba(139, 92, 246, 0.12), transparent 30%),
                            radial-gradient(circle at 70% 10%, rgba(16, 185, 129, 0.1), transparent 25%),
                            radial-gradient(circle at 80% 40%, rgba(14, 165, 233, 0.1), transparent 25%);
                filter: blur(50px);
                z-index: 0;
            }

            .bg-card-bg { background-color: var(--card-bg); }
            .bg-editor-bg { background-color: var(--editor-bg); }

            .custom-scrollbar::-webkit-scrollbar { width: 8px; height: 8px; }
            .custom-scrollbar::-webkit-scrollbar-track { background: transparent; }
            .custom-scrollbar::-webkit-scrollbar-thumb { background: #334155; border-radius: 6px; }
            .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #475569; }

            .tree-view {
                background: var(--editor-bg);
                border: 1px solid rgba(255, 255, 255, 0.05);
                border-radius: 12px;
                padding: 10px;
                max-height: 640px;
                overflow: auto;
                font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono';
                font-size: 13px;
            }

            .tree-view-content { display: block; }
            .tree-node { color: var(--text-primary); padding: 2px 0; }
            .tree-key { color: #facc15; }
            .tree-string { color: #a5b4fc; }
            .tree-number { color: #34d399; }
            .tree-boolean { color: #60a5fa; }
            .tree-null { color: var(--text-muted); }
            .tree-value { color: #cbd5e1; }
            .tree-count { color: var(--text-muted); margin-left: 8px; font-size: 12px; }
            .tree-toggle { cursor: pointer; margin-right: 6px; color: #cbd5e1; user-select: none; }
            .tree-children.collapsed { display: none; }

            .add-btn, .add-inline { color: #22c55e; }
            .add-inline { font-size: 11px; }
            .delete-btn { color: #f43f5e; }

            /* Show add/delete controls only on hover for clarity */
            .tree-node .add-btn,
            .tree-node .add-inline,
            .tree-node .delete-btn {
                opacity: 0;
                transition: opacity 120ms ease;
            }

            .tree-node:hover .add-btn,
            .tree-node:hover .add-inline,
            .tree-node:hover .delete-btn {
                opacity: 1;
            }

            .tree-size { color: var(--text-muted); margin-left: 8px; font-size: 12px; }
            .size-percentage { margin-left: 4px; padding: 0 6px; border-radius: 10px; background: rgba(255, 255, 255, 0.06); }
            .size-tiny { color: #06b6d4; }
            .size-small { color: #10b981; }
            .size-medium { color: #f59e0b; }
            .size-large { color: #f97316; }

            .search-highlight { background-color: rgba(250, 204, 21, 0.12); border-radius: 4px; }
            .current-match { outline: 1px solid rgba(250, 204, 21, 0.7); outline-offset: 2px; }
            .highlight { background-color: rgba(250, 204, 21, 0.35); border-radius: 2px; }

            .diff-container { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
            .diff-panel { background: var(--editor-bg); border: 1px solid rgba(255, 255, 255, 0.05); border-radius: 12px; padding: 12px; color: var(--text-primary); }
            .diff-removed { color: #f87171; }
            .diff-added { color: #4ade80; }
            .diff-modified { color: #eab308; }

            .btn { transition: transform 0.1s ease; }
            .btn:active { transform: translateY(1px); }

            .maximized { position: fixed; inset: 12px; z-index: 9998; background: var(--editor-bg); padding: 12px; border: 1px solid rgba(255, 255, 255, 0.08); border-radius: 12px; max-height: calc(100vh - 24px); padding-top: 80px; }
            .has-maximized-view { overflow: hidden; }
            .tree-view .editing { background: rgba(255, 255, 255, 0.03); }

            /* Ensure search bar stays on top of the maximized tree view */
            body.has-maximized-view .tool-section.active > div > div:first-child {
                position: fixed;
                top: 25px;
                left: 25px;
                right: 25px;
                z-index: 10001;
                background: var(--card-bg);
                padding: 12px;
                border-radius: 12px;
                box-shadow: 0 10px 30px rgba(0,0,0,0.5);
                border: 1px solid rgba(255,255,255,0.1);
            }

            .resizer-h {
                width: 8px;
                cursor: col-resize;
                background: transparent;
                transition: background 0.2s;
                position: relative;
                z-index: 10;
                margin: 0 -2px; /* Pulls it slightly over siblings for better hit area without pushing them */
            }
            .resizer-h::before {
                content: "";
                position: absolute;
                left: 2px;
                right: 2px;
                top: 0;
                bottom: 0;
                background: transparent;
                border-radius: 2px;
                transition: background 0.2s;
            }
            .resizer-h:hover::before, .resizer-h.resizing::before {
                background: var(--accent);
            }

        </style>
</head>
<body class="min-h-screen flex flex-col items-center py-10 px-4 relative overflow-x-hidden">
        <div class="ambient-glow"></div>
        <header class="text-center relative z-10 mb-10">
            <div class="flex items-center justify-center gap-3 mb-2">
                <i class="fas fa-file-code text-purple-400 text-3xl"></i>
                <h1 class="text-3xl font-bold text-white tracking-tight">JSON Toolbox</h1>
            </div>
            <p class="text-slate-400 text-sm font-medium">Parser, Sizer & Diff tools in a modern UI</p>
        </header>

        <nav class="relative z-10 mb-8 bg-white/5 backdrop-blur-md border border-white/10 rounded-full p-1 flex items-center shadow-lg">
            <button class="tab-btn flex items-center gap-2 px-6 py-2 rounded-full bg-gradient-to-b from-purple-500 to-purple-700 text-white font-medium shadow-[0_0_15px_rgba(139,92,246,0.4)] transition-all" onclick="switchTab('parser', event)">Parser/Viewer</button>
            <button class="tab-btn flex items-center gap-2 px-6 py-2 rounded-full text-slate-300 hover:text-white hover:bg-white/5 transition-colors" onclick="switchTab('sizer', event)">Sizer Helper</button>
            <button class="tab-btn flex items-center gap-2 px-6 py-2 rounded-full text-slate-300 hover:text-white hover:bg-white/5 transition-colors" onclick="switchTab('diff', event)">Diff Tool</button>
        </nav>

        <main class="w-full max-w-[1400px] bg-card-bg border border-slate-700/50 rounded-2xl shadow-2xl overflow-hidden relative z-10">
            <section class="p-6 space-y-10">
                <!-- Parser/Viewer Tool -->
                <div id="parser" class="tool-section active space-y-4">
                    <div class="flex flex-col gap-4 bg-card-bg/70 border border-white/5 rounded-2xl p-4 shadow-inner">
                        <div class="flex flex-col xl:flex-row gap-3 items-start xl:items-center">
                            <div class="flex flex-wrap gap-2">
                                <label class="relative inline-flex items-center gap-2 bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-lg text-sm font-semibold shadow-lg shadow-blue-900/30 cursor-pointer">
                                    <span>Upload JSON</span>
                                    <input type="file" class="absolute inset-0 opacity-0 cursor-pointer" id="parserFileInput" accept=".json" onchange="loadFile('parser')">
                                </label>
                                <button class="btn bg-gradient-to-r from-purple-500 to-indigo-500 hover:from-purple-400 hover:to-indigo-400 text-white px-4 py-2 rounded-lg text-sm font-semibold shadow-md" onclick="processParser()">Beautify & View</button>
                                <button class="btn border border-slate-600 text-slate-200 hover:bg-white/5 px-4 py-2 rounded-lg text-sm font-semibold" onclick="clearInput('parser')">Clear</button>
                            </div>
                            <div class="flex-1 w-full xl:w-auto">
                                <div class="flex items-center gap-2">
                                    <div class="relative flex-1 min-w-[220px]">
                                        <i class="fa-solid fa-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-slate-500"></i>
                                        <input id="parserSearch" class="search-box bg-[#050814] border border-slate-700 text-white text-sm rounded-lg focus:ring-1 focus:ring-purple-500 focus:border-purple-500 block w-full pl-10 p-2 placeholder-slate-500 transition-all shadow-inner" placeholder="Search in JSON..." type="text" oninput="searchInTree('parser')">
                                    </div>
                                    <div class="search-navigation flex items-center gap-2" id="parserSearchNav">
                                        <button class="btn bg-slate-800 hover:bg-slate-700 text-slate-100 px-3 py-2 rounded-md text-xs font-semibold" onclick="previousSearchResult('parser')">Prev</button>
                                        <span class="text-slate-300 text-xs" id="parserSearchCount">0/0</span>
                                        <button class="btn bg-slate-800 hover:bg-slate-700 text-slate-100 px-3 py-2 rounded-md text-xs font-semibold" onclick="nextSearchResult('parser')">Next</button>
                                    </div>
                                </div>
                            </div>
                            <div class="flex flex-wrap gap-2">
                                <button class="btn bg-[#2a2f3d] hover:bg-[#353b4d] text-slate-200 px-3 py-2 rounded-lg text-xs font-semibold" onclick="expandAll('parser')">Expand All</button>
                                <button class="btn bg-[#2a2f3d] hover:bg-[#353b4d] text-slate-200 px-3 py-2 rounded-lg text-xs font-semibold" onclick="collapseAll('parser')">Collapse All</button>
                                <button id="parserMaximizeBtn" class="btn bg-[#2a2f3d] hover:bg-[#353b4d] text-slate-200 px-3 py-2 rounded-lg text-xs font-semibold" onclick="toggleFullscreen('parser')">Maximize</button>
                            </div>
                        </div>

                        <div class="flex flex-col lg:flex-row gap-0">
                            <div class="bg-editor-bg border border-white/5 rounded-xl p-4 shadow-inner flex flex-col min-w-[100px]" style="flex: 1 1 0%;">
                                <div class="flex items-center justify-between mb-2 text-xs uppercase tracking-wide text-slate-400">
                                    <span class="text-slate-300 font-semibold">Raw JSON</span>
                                    <span class="text-slate-500">Parser Input</span>
                                </div>
                                <textarea id="parserInput" class="flex-1 min-h-[400px] w-full bg-[#0b1021] text-slate-100 border border-slate-700 rounded-lg p-3 text-sm font-mono custom-scrollbar resize-none focus:ring-1 focus:ring-purple-500" placeholder="Paste your JSON here..."></textarea>
                            </div>

                            <div class="resizer-h hidden lg:block" data-target-prev="true"></div>

                            <div class="bg-editor-bg border border-white/5 rounded-xl p-4 shadow-inner flex flex-col gap-3 min-w-[100px]" style="flex: 1 1 50%;">
                                <div class="flex items-center justify-between mb-1 text-xs uppercase tracking-wide text-slate-400 flex-wrap gap-2">
                                    <div class="flex items-center gap-2">
                                        <span class="text-slate-300 font-semibold">Tree View</span>
                                        <span class="text-slate-500">Parser Output</span>
                                    </div>
                                    <div class="flex items-center gap-2 text-[11px]">
                                        <select id="parserExportFormat" class="bg-[#0b1021] border border-slate-700 text-slate-100 rounded-md px-2 py-1 focus:ring-1 focus:ring-purple-500 focus:border-purple-500">
                                            <option value="json">JSON</option>
                                            <option value="yaml">YAML</option>
                                        </select>
                                        <button class="btn bg-[#2a2f3d] hover:bg-[#353b4d] text-slate-200 px-3 py-1 rounded-lg text-xs font-semibold" onclick="copyParserExport()">Copy</button>
                                        <button class="btn bg-[#2a2f3d] hover:bg-[#353b4d] text-slate-200 px-3 py-1 rounded-lg text-xs font-semibold" onclick="downloadParserExport()">Download</button>
                                    </div>
                                </div>
                                <div id="parserOutput" class="tree-view custom-scrollbar"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Sizer Helper Tool -->
                <div id="sizer" class="tool-section space-y-4 hidden">
                    <div class="flex flex-col gap-4 bg-card-bg/70 border border-white/5 rounded-2xl p-4 shadow-inner">
                        <div class="flex flex-col xl:flex-row gap-3 items-start xl:items-center">
                            <div class="flex flex-wrap gap-2">
                                <label class="relative inline-flex items-center gap-2 bg-blue-600 hover:bg-blue-500 text-white px-4 py-2 rounded-lg text-sm font-semibold shadow-lg shadow-blue-900/30 cursor-pointer">
                                    <span>Upload JSON</span>
                                    <input type="file" class="absolute inset-0 opacity-0 cursor-pointer" id="sizerFileInput" accept=".json" onchange="loadFile('sizer')">
                                </label>
                                <button class="btn bg-gradient-to-r from-purple-500 to-indigo-500 hover:from-purple-400 hover:to-indigo-400 text-white px-4 py-2 rounded-lg text-sm font-semibold shadow-md" onclick="processSizer()">Calculate Sizes</button>
                                <button class="btn border border-slate-600 text-slate-200 hover:bg-white/5 px-4 py-2 rounded-lg text-sm font-semibold" onclick="clearInput('sizer')">Clear</button>
                            </div>
                            <div class="flex-1 w-full xl:w-auto">
                                <div class="flex items-center gap-2">
                                    <div class="relative flex-1 min-w-[220px]">
                                        <i class="fa-solid fa-magnifying-glass absolute left-3 top-1/2 -translate-y-1/2 text-slate-500"></i>
                                        <input id="sizerSearch" class="search-box bg-[#050814] border border-slate-700 text-white text-sm rounded-lg focus:ring-1 focus:ring-purple-500 focus:border-purple-500 block w-full pl-10 p-2 placeholder-slate-500 transition-all shadow-inner" placeholder="Search in JSON..." type="text" oninput="searchInTree('sizer')">
                                    </div>
                                    <div class="search-navigation flex items-center gap-2" id="sizerSearchNav">
                                        <button class="btn bg-slate-800 hover:bg-slate-700 text-slate-100 px-3 py-2 rounded-md text-xs font-semibold" onclick="previousSearchResult('sizer')">Prev</button>
                                        <span class="text-slate-300 text-xs" id="sizerSearchCount">0/0</span>
                                        <button class="btn bg-slate-800 hover:bg-slate-700 text-slate-100 px-3 py-2 rounded-md text-xs font-semibold" onclick="nextSearchResult('sizer')">Next</button>
                                    </div>
                                </div>
                            </div>
                            <div class="flex flex-wrap gap-2">
                                <button class="btn bg-[#2a2f3d] hover:bg-[#353b4d] text-slate-200 px-3 py-2 rounded-lg text-xs font-semibold" onclick="expandAll('sizer')">Expand All</button>
                                <button class="btn bg-[#2a2f3d] hover:bg-[#353b4d] text-slate-200 px-3 py-2 rounded-lg text-xs font-semibold" onclick="collapseAll('sizer')">Collapse All</button>
                                <button id="sizerMaximizeBtn" class="btn bg-[#2a2f3d] hover:bg-[#353b4d] text-slate-200 px-3 py-2 rounded-lg text-xs font-semibold" onclick="toggleFullscreen('sizer')">Maximize</button>
                            </div>
                        </div>

                        <div class="flex flex-col lg:flex-row gap-0">
                            <div class="bg-editor-bg border border-white/5 rounded-xl p-4 shadow-inner flex flex-col min-w-[100px]" style="flex: 1 1 0%;">
                                <div class="flex items-center justify-between mb-2 text-xs uppercase tracking-wide text-slate-400">
                                    <span class="text-slate-300 font-semibold">Raw JSON</span>
                                    <span class="text-slate-500">Sizer Input</span>
                                </div>
                                <textarea id="sizerInput" class="flex-1 min-h-[400px] w-full bg-[#0b1021] text-slate-100 border border-slate-700 rounded-lg p-3 text-sm font-mono custom-scrollbar resize-none focus:ring-1 focus:ring-purple-500" placeholder="Paste your JSON here..."></textarea>
                            </div>

                            <div class="resizer-h hidden lg:block" data-target-prev="true"></div>

                            <div class="bg-editor-bg border border-white/5 rounded-xl p-4 shadow-inner flex flex-col gap-3 min-w-[100px]" style="flex: 1 1 0%;">
                                <div class="flex items-center justify-between mb-1 text-xs uppercase tracking-wide text-slate-400">
                                    <span class="text-slate-300 font-semibold">Tree View</span>
                                    <span class="text-slate-500">Sizer Output</span>
                                </div>
                                <div id="sizerOutput" class="tree-view custom-scrollbar"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Diff Tool -->
                <div id="diff" class="tool-section space-y-4 hidden">
                    <div class="flex flex-col gap-4 bg-card-bg/70 border border-white/5 rounded-2xl p-4 shadow-inner">
                        <div class="grid lg:grid-cols-2 gap-4">
                            <div class="bg-editor-bg border border-white/5 rounded-xl p-4 shadow-inner flex flex-col">
                                <div class="flex items-center justify-between mb-2 text-xs uppercase tracking-wide text-slate-400">
                                    <span class="text-slate-300 font-semibold">First JSON</span>
                                    <label class="relative inline-flex items-center gap-2 bg-blue-600 hover:bg-blue-500 text-white px-3 py-1 rounded-md text-xs font-semibold shadow-md cursor-pointer">
                                        <span>Upload</span>
                                        <input type="file" class="absolute inset-0 opacity-0 cursor-pointer" id="diff1FileInput" accept=".json" onchange="loadFile('diff1')">
                                    </label>
                                </div>
                                <textarea id="diff1Input" class="flex-1 w-full bg-[#0b1021] text-slate-100 border border-slate-700 rounded-lg p-3 text-sm font-mono custom-scrollbar resize-none focus:ring-1 focus:ring-purple-500" placeholder="Paste first JSON here..."></textarea>
                                <div class="mt-3">
                                    <button class="btn border border-slate-600 text-slate-200 hover:bg-white/5 px-3 py-2 rounded-lg text-xs font-semibold" onclick="clearInput('diff1')">Clear</button>
                                </div>
                            </div>
                            <div class="bg-editor-bg border border-white/5 rounded-xl p-4 shadow-inner flex flex-col">
                                <div class="flex items-center justify-between mb-2 text-xs uppercase tracking-wide text-slate-400">
                                    <span class="text-slate-300 font-semibold">Second JSON</span>
                                    <label class="relative inline-flex items-center gap-2 bg-blue-600 hover:bg-blue-500 text-white px-3 py-1 rounded-md text-xs font-semibold shadow-md cursor-pointer">
                                        <span>Upload</span>
                                        <input type="file" class="absolute inset-0 opacity-0 cursor-pointer" id="diff2FileInput" accept=".json" onchange="loadFile('diff2')">
                                    </label>
                                </div>
                                <textarea id="diff2Input" class="flex-1 w-full bg-[#0b1021] text-slate-100 border border-slate-700 rounded-lg p-3 text-sm font-mono custom-scrollbar resize-none focus:ring-1 focus:ring-purple-500" placeholder="Paste second JSON here..."></textarea>
                                <div class="mt-3">
                                    <button class="btn border border-slate-600 text-slate-200 hover:bg-white/5 px-3 py-2 rounded-lg text-xs font-semibold" onclick="clearInput('diff2')">Clear</button>
                                </div>
                            </div>
                        </div>

                        <div class="flex items-center justify-between flex-wrap gap-3">
                            <button class="btn bg-gradient-to-r from-purple-500 to-indigo-500 hover:from-purple-400 hover:to-indigo-400 text-white px-4 py-2 rounded-lg text-sm font-semibold shadow-md" onclick="processDiff()">Compare JSONs</button>
                            <p class="text-slate-400 text-xs">Outputs show differences, missing keys, and mismatched values.</p>
                        </div>

                        <div id="diffOutput" class="diff-container"></div>
                    </div>
                </div>
            </section>
        </main>

        <footer class="mt-6 text-slate-500 text-xs">© 2026 JSON Toolbox. All rights reserved.</footer>

        <script>
        // Global variables for storing parsed data
        let parserData = null;           // parsed from input (source of truth for original)
        let sizerData = null;
        let editableParserData = null;   // editable copy for the tree
        let editableSizerData = null;
        let searchMatches = [];
        let currentSearchIndex = 0;
        let isEditing = false;

        // Resizer Logic
        function initResizers() {
            document.querySelectorAll('.resizer-h').forEach(resizer => {
                const prev = resizer.previousElementSibling;
                const next = resizer.nextElementSibling;
                if (!prev || !next) return;

                // Ensure containers don't collapse too much and have correct flex base
                next.style.flex = "1 1 0%"; 

                resizer.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    const startX = e.clientX;
                    const startWidthPrev = prev.getBoundingClientRect().width;
                    const parentWidth = resizer.parentElement.getBoundingClientRect().width;
                    
                    resizer.classList.add('resizing');
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                    
                    const onMouseMove = (moveEvent) => {
                        const dx = moveEvent.clientX - startX;
                        let newPrevWidth = startWidthPrev + dx;
                        
                        // Constraints (min 100px on both sides approx)
                        if (newPrevWidth < 100) newPrevWidth = 100;
                        if (newPrevWidth > parentWidth - 100) newPrevWidth = parentWidth - 100;

                        const prevPercent = (newPrevWidth / parentWidth) * 100;
                        prev.style.flex = `0 0 ${prevPercent}%`;
                        prev.style.maxWidth = `${prevPercent}%`; // Double security
                    };

                    const onMouseUp = () => {
                        resizer.classList.remove('resizing');
                        document.body.style.cursor = 'default';
                        document.body.style.userSelect = '';
                        document.removeEventListener('mousemove', onMouseMove);
                        document.removeEventListener('mouseup', onMouseUp);
                    };

                    document.addEventListener('mousemove', onMouseMove);
                    document.addEventListener('mouseup', onMouseUp);
                });
            });
        }

        document.addEventListener('DOMContentLoaded', initResizers);

        // Switch between tabs and sync pills/sections
        function switchTab(tabName, event) {
            document.querySelectorAll('.tool-section').forEach(section => {
                section.classList.add('hidden');
                section.classList.remove('active');
            });

            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.classList.remove('bg-gradient-to-b', 'from-purple-500', 'to-purple-700', 'text-white', 'shadow-[0_0_15px_rgba(139,92,246,0.4)]', 'border', 'border-purple-300/40');
                btn.classList.add('text-slate-300', 'hover:text-white', 'hover:bg-white/5');
            });

            const targetSection = document.getElementById(tabName);
            if (targetSection) {
                targetSection.classList.remove('hidden');
                targetSection.classList.add('active');
            }

            const targetBtn = event?.target?.closest('.tab-btn');
            if (targetBtn) {
                targetBtn.classList.add('bg-gradient-to-b', 'from-purple-500', 'to-purple-700', 'text-white', 'shadow-[0_0_15px_rgba(139,92,246,0.4)]', 'border', 'border-purple-300/40');
                targetBtn.classList.remove('text-slate-300', 'hover:text-white', 'hover:bg-white/5');
            }
        }

        // Load file content
        function loadFile(toolName) {
            const fileInput = document.getElementById(toolName + 'FileInput');
            const file = fileInput.files[0];
            
            if (file) {
                const reader = new FileReader();
                reader.onload = function(e) {
                    document.getElementById(toolName + 'Input').value = e.target.result;
                };
                reader.readAsText(file);
            }
        }

        // Clear input
        function clearInput(toolName) {
            document.getElementById(toolName + 'Input').value = '';
            if (toolName === 'parser') {
                document.getElementById('parserOutput').innerHTML = '';
                document.getElementById('parserSearch').value = '';
                parserData = null;
            } else if (toolName === 'sizer') {
                document.getElementById('sizerOutput').innerHTML = '';
                sizerData = null;
            } else if (toolName === 'diff1' || toolName === 'diff2') {
                // Don't clear output for diff, only the input
            }
        }

        // Calculate byte size of a string
        function getByteSize(str) {
            return new Blob([str]).size;
        }

        // Calculate size of a value for sorting
        function getValueSize(value) {
            if (value === null) return getByteSize('null');
            if (typeof value === 'object') return getByteSize(JSON.stringify(value));
            if (typeof value === 'string') return getByteSize('"' + value + '"');
            return getByteSize(value.toString());
        }

        // Get CSS class based on size percentage
        function getSizeClass(percentage) {
            if (percentage < 5) return 'size-tiny';
            if (percentage < 15) return 'size-small';
            if (percentage < 30) return 'size-medium';
            return 'size-large';
        }

        function getSizeSpan(size, totalSize) {
            let span = '<span class="tree-size">' + size + ' bytes';
            if (totalSize > 0) {
                const percentage = ((size / totalSize) * 100);
                const percentageStr = percentage.toFixed(2);
                const sizeClass = getSizeClass(percentage);
                span += ' <span class="size-percentage ' + sizeClass + '">(' + percentageStr + '%)</span>';
            }
            span += '</span>';
            return span;
        }

        // Process Parser/Viewer
        function processParser() {
            const input = document.getElementById('parserInput').value.trim();
            const output = document.getElementById('parserOutput');
            
            if (!input) {
                output.innerHTML = '<div class="error-message">Please provide JSON input</div>';
                return;
            }
            
            try {
                parserData = JSON.parse(input);
                editableParserData = deepClone(parserData);
                output.innerHTML = buildTreeView(editableParserData, '', false);
                attachEditableHandlers('parser');
            } catch (e) {
                output.innerHTML = '<div class="error-message">Invalid JSON: ' + e.message + '</div>';
            }
        }

        function getSelectedParserFormat() {
            const select = document.getElementById('parserExportFormat');
            return (select?.value || 'json').toLowerCase();
        }

        function prepareParserExport() {
            if (!editableParserData) {
                alert('Please process JSON in the Parser/Viewer first.');
                return null;
            }

            const format = getSelectedParserFormat();
            let payload = '';

            if (format === 'yaml') {
                payload = convertToYaml(editableParserData);
            } else {
                payload = JSON.stringify(editableParserData, null, 2);
            }

            return { payload, format };
        }

        function copyParserExport() {
            const exportData = prepareParserExport();
            if (!exportData) return;

            const { payload } = exportData;

            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(payload).catch(() => fallbackCopyText(payload));
            } else {
                fallbackCopyText(payload);
            }
        }

        function fallbackCopyText(text) {
            const textarea = document.createElement('textarea');
            textarea.value = text;
            textarea.style.position = 'fixed';
            textarea.style.opacity = '0';
            document.body.appendChild(textarea);
            textarea.select();
            document.execCommand('copy');
            document.body.removeChild(textarea);
        }

        function downloadParserExport() {
            const exportData = prepareParserExport();
            if (!exportData) return;

            const { payload, format } = exportData;
            const blob = new Blob([payload], { type: format === 'yaml' ? 'text/yaml' : 'application/json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = 'parser-output.' + (format === 'yaml' ? 'yaml' : 'json');
            document.body.appendChild(link);
            link.click();
            link.remove();
            URL.revokeObjectURL(url);
        }

        function convertToYaml(value) {
            return toYaml(value, 0);
        }

        function toYaml(value, indentLevel) {
            const indent = '  '.repeat(indentLevel);

            if (value === null) return 'null';
            if (typeof value === 'number' || typeof value === 'boolean') return String(value);
            if (typeof value === 'string') return formatYamlString(value);

            if (Array.isArray(value)) {
                if (value.length === 0) return '[]';
                return value.map(item => {
                    const serialized = toYaml(item, indentLevel + 1);
                    const childIndent = '  '.repeat(indentLevel + 1);
                    const lines = serialized.split('\n').map(line => line.startsWith(childIndent) ? line.slice(childIndent.length) : line);
                    if (lines.length === 1 && isYamlInline(item)) {
                        return `${indent}- ${lines[0]}`;
                    }
                    const indented = lines.map((line, idx) => idx === 0 ? `${indent}- ${line}` : `${indent}  ${line}`).join('\n');
                    return indented;
                }).join('\n');
            }

            if (typeof value === 'object') {
                const entries = Object.entries(value);
                if (entries.length === 0) return '{}';

                return entries.map(([key, val]) => {
                    const safeKey = formatYamlString(key);
                    const serialized = toYaml(val, indentLevel + 1);
                    const childIndent = '  '.repeat(indentLevel + 1);
                    const lines = serialized.split('\n').map(line => line.startsWith(childIndent) ? line.slice(childIndent.length) : line);

                    if (lines.length === 1 && isYamlInline(val)) {
                        return `${indent}${safeKey}: ${lines[0]}`;
                    }

                    const indented = lines.map(line => `${indent}  ${line}`).join('\n');
                    return `${indent}${safeKey}:\n${indented}`;
                }).join('\n');
            }

            return '';
        }

        function isYamlInline(value) {
            if (value === null) return true;
            if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') return true;
            if (Array.isArray(value)) return value.length === 0;
            if (typeof value === 'object') return Object.keys(value).length === 0;
            return false;
        }

        function formatYamlString(str) {
            const needsQuoting = str === '' || /^\s|\s$/.test(str) || /[:\-\?\[\]\{\},&\*#\!\|>\'%@`]/.test(str) || str.includes('\n');
            if (needsQuoting) {
                return JSON.stringify(str);
            }
            return str;
        }

        // Build tree view for parser/sizer
        function buildTreeView(data, path, showSize, totalSize = 0, allowEdit = true) {
            let html = '<div class="tree-view-content">';
            html += buildTreeNode(data, '', path, 0, showSize, totalSize, allowEdit);
            html += '</div>';
            return html;
        }

        // Build a single tree node
        function buildTreeNode(data, key, path, level, showSize, totalSize = 0, allowEdit = true) {
            const currentPath = path ? (key ? path + '.' + key : path) : key;
            let html = '';
            
            if (data === null) {
                html += '<div class="tree-node" style="margin-left: ' + (level * 25) + 'px;">';
                if (key) {
                    const keyAttrs = allowEdit ? 'class="tree-key editable-value" data-path="' + currentPath + '" data-editable-key="true" contenteditable="true"' : 'class="tree-key"';
                    html += '<span ' + keyAttrs + '>"' + key + '"</span>: ';
                }
                const nullAttrs = allowEdit ? 'class="tree-null editable-value" data-path="' + currentPath + '" data-editable-value="true" contenteditable="true"' : 'class="tree-null"';
                html += '<span ' + nullAttrs + '>null</span>';
                if (allowEdit && currentPath) {
                    html += '<button class="ml-1 text-[10px] text-emerald-300 hover:text-emerald-100 add-inline" data-insert="after" data-insert-path="' + currentPath + '">＋</button>';
                }
                if (showSize) {
                    const size = getByteSize('null');
                    html += getSizeSpan(size, totalSize);
                }
                if (allowEdit && currentPath) html += '<button class="ml-2 text-xs text-rose-300 hover:text-rose-200 delete-btn" data-delete-path="' + currentPath + '">✕</button>';
                html += '</div>';
            } else if (typeof data === 'object') {
                const isArray = Array.isArray(data);
                const entries = isArray ? data : Object.entries(data);
                const count = isArray ? data.length : Object.keys(data).length;
                const nodeId = 'node-' + Math.random().toString(36).substring(2, 11);
                
                html += '<div class="tree-node" style="margin-left: ' + (level * 25) + 'px;">';
                html += '<span class="tree-toggle" onclick="toggleNode(\'' + nodeId + '\', event)">▼</span>';
                if (key) {
                    const keyAttrs = allowEdit ? 'class="tree-key editable-value" data-path="' + currentPath + '" data-editable-key="true" contenteditable="true"' : 'class="tree-key"';
                    html += '<span ' + keyAttrs + '>"' + key + '"</span>: ';
                }
                html += '<span class="tree-value">' + (isArray ? '[' : '{') + '</span>';
                html += '<span class="tree-count">' + count + ' ' + (isArray ? 'items' : 'properties') + '</span>';
                if (allowEdit) html += '<button class="ml-2 text-xs text-emerald-300 hover:text-emerald-200 add-btn" data-add-type="' + (isArray ? 'array' : 'object') + '" data-add-path="' + currentPath + '">＋</button>';
                if (allowEdit && currentPath) html += '<button class="ml-2 text-xs text-rose-300 hover:text-rose-200 delete-btn" data-delete-path="' + currentPath + '">✕</button>';
                
                if (showSize) {
                    const size = getByteSize(JSON.stringify(data));
                    html += getSizeSpan(size, totalSize);
                }
                
                html += '</div>';
                
                html += '<div id="' + nodeId + '" class="tree-children">';
                if (isArray) {
                    // Sort array items by size descending for sizer tool
                    let items = data.map((item, index) => ({
                        value: item,
                        index: index,
                        size: getValueSize(item)
                    }));
                    
                    if (showSize && totalSize > 0) {
                        items.sort((a, b) => b.size - a.size);
                    } else {
                        items.sort((a, b) => a.index - b.index); // Keep original order if not sizing
                    }
                    
                    items.forEach(item => {
                        html += buildTreeNode(item.value, '[' + item.index + ']', currentPath, level + 1, showSize, totalSize, allowEdit);
                    });
                } else {
                    // Sort properties by size descending for sizer tool
                    let entries = Object.entries(data);
                    if (showSize && totalSize > 0) {
                        entries = entries.map(([k, v]) => ({
                            key: k,
                            value: v,
                            size: getValueSize(v)
                        })).sort((a, b) => b.size - a.size);
                        
                        entries.forEach(entry => {
                            html += buildTreeNode(entry.value, entry.key, currentPath, level + 1, showSize, totalSize, allowEdit);
                        });
                    } else {
                        entries.forEach(([k, v]) => {
                            html += buildTreeNode(v, k, currentPath, level + 1, showSize, totalSize, allowEdit);
                        });
                    }
                }
                html += '</div>';
                
                html += '<div class="tree-node" style="margin-left: ' + (level * 25) + 'px;">';
                html += '<span class="tree-value">' + (isArray ? ']' : '}') + '</span>';
                html += '</div>';
            } else if (typeof data === 'string') {
                html += '<div class="tree-node" style="margin-left: ' + (level * 25) + 'px;">';
                if (key) {
                    const keyAttrs = allowEdit ? 'class="tree-key editable-value" data-path="' + currentPath + '" data-editable-key="true" contenteditable="true"' : 'class="tree-key"';
                    html += '<span ' + keyAttrs + '>"' + key + '"</span>: ';
                }
                const strAttrs = allowEdit ? 'class="tree-string editable-value" data-path="' + currentPath + '" data-editable-value="true" contenteditable="true"' : 'class="tree-string"';
                html += '<span ' + strAttrs + '>"' + escapeHtml(data) + '"</span>';
                if (allowEdit && currentPath) {
                    html += '<button class="ml-1 text-[10px] text-emerald-300 hover:text-emerald-100 add-inline" data-insert="after" data-insert-path="' + currentPath + '">＋</button>';
                }
                if (showSize) {
                    const size = getByteSize('"' + data + '"');
                    html += getSizeSpan(size, totalSize);
                }
                if (allowEdit && currentPath) html += '<button class="ml-2 text-xs text-rose-300 hover:text-rose-200 delete-btn" data-delete-path="' + currentPath + '">✕</button>';
                html += '</div>';
            } else if (typeof data === 'number') {
                html += '<div class="tree-node" style="margin-left: ' + (level * 25) + 'px;">';
                if (key) {
                    const keyAttrs = allowEdit ? 'class="tree-key editable-value" data-path="' + currentPath + '" data-editable-key="true" contenteditable="true"' : 'class="tree-key"';
                    html += '<span ' + keyAttrs + '>"' + key + '"</span>: ';
                }
                const numAttrs = allowEdit ? 'class="tree-number editable-value" data-path="' + currentPath + '" data-editable-value="true" contenteditable="true"' : 'class="tree-number"';
                html += '<span ' + numAttrs + '>' + data + '</span>';
                if (allowEdit && currentPath) {
                    html += '<button class="ml-1 text-[10px] text-emerald-300 hover:text-emerald-100 add-inline" data-insert="after" data-insert-path="' + currentPath + '">＋</button>';
                }
                if (showSize) {
                    const size = getByteSize(data.toString());
                    html += getSizeSpan(size, totalSize);
                }
                if (allowEdit && currentPath) html += '<button class="ml-2 text-xs text-rose-300 hover:text-rose-200 delete-btn" data-delete-path="' + currentPath + '">✕</button>';
                html += '</div>';
            } else if (typeof data === 'boolean') {
                html += '<div class="tree-node" style="margin-left: ' + (level * 25) + 'px;">';
                if (key) {
                    const keyAttrs = allowEdit ? 'class="tree-key editable-value" data-path="' + currentPath + '" data-editable-key="true" contenteditable="true"' : 'class="tree-key"';
                    html += '<span ' + keyAttrs + '>"' + key + '"</span>: ';
                }
                const boolAttrs = allowEdit ? 'class="tree-boolean editable-value" data-path="' + currentPath + '" data-editable-value="true" contenteditable="true"' : 'class="tree-boolean"';
                html += '<span ' + boolAttrs + '>' + data + '</span>';
                if (allowEdit && currentPath) {
                    html += '<button class="ml-1 text-[10px] text-emerald-300 hover:text-emerald-100 add-inline" data-insert="after" data-insert-path="' + currentPath + '">＋</button>';
                }
                if (showSize) {
                    const size = getByteSize(data.toString());
                    html += getSizeSpan(size, totalSize);
                }
                if (allowEdit && currentPath) html += '<button class="ml-2 text-xs text-rose-300 hover:text-rose-200 delete-btn" data-delete-path="' + currentPath + '">✕</button>';
                html += '</div>';
            }
            
            return html;
        }

        // Toggle tree node
        function toggleNode(nodeId, event) {
            const node = document.getElementById(nodeId);
            const toggle = event.target;
            
            if (node.classList.contains('collapsed')) {
                node.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                node.classList.add('collapsed');
                toggle.textContent = '►';
            }
        }

        // Expand all tree nodes
        function expandAll(toolName) {
            const output = document.getElementById(toolName + 'Output');
            const nodes = output.querySelectorAll('[id^="node-"]');
            const toggles = output.querySelectorAll('.tree-toggle');
            
            nodes.forEach(node => node.classList.remove('collapsed'));
            toggles.forEach(toggle => toggle.textContent = '▼');
        }

        // Collapse all tree nodes
        function collapseAll(toolName) {
            const output = document.getElementById(toolName + 'Output');
            const nodes = output.querySelectorAll('[id^="node-"]');
            const toggles = output.querySelectorAll('.tree-toggle');
            
            nodes.forEach(node => node.classList.add('collapsed'));
            toggles.forEach(toggle => toggle.textContent = '►');
        }

        // Search in tree
        function searchInTree(toolName) {
            const searchTerm = document.getElementById(toolName + 'Search').value.toLowerCase().trim();
            const output = document.getElementById(toolName + 'Output');
            const dataRef = toolName === 'parser' ? editableParserData : editableSizerData;
            if (!dataRef) return;

            const allowEdit = toolName !== 'sizer';
            
            if (!searchTerm) {
                searchMatches = [];
                currentSearchIndex = 0;
                const countElement = document.getElementById(toolName + 'SearchCount');
                if (countElement) countElement.textContent = '0/0';
                return rerenderTool(toolName);
            }

            output.innerHTML = buildTreeViewWithSearch(dataRef, searchTerm, allowEdit);
            if (allowEdit) attachEditableHandlers(toolName);
            updateSearchNavigation(toolName, searchTerm);
        }

        // Update search navigation UI
        function updateSearchNavigation(toolName, searchTerm) {
            const countElement = document.getElementById(toolName + 'SearchCount');
            const total = searchMatches.length;
            const currentDisplay = total > 0 ? 1 : 0;
            countElement.textContent = `${currentDisplay}/${total}`;

            if (searchTerm.length > 0 && total > 0) {
                scrollToSearchMatch(0);
            }
        }

        // Navigate to next search result
        function nextSearchResult(toolName) {
            if (searchMatches.length === 0) return;
            
            currentSearchIndex = (currentSearchIndex + 1) % searchMatches.length;
            scrollToSearchMatch(currentSearchIndex);
            updateSearchCounter(toolName);
        }

        // Navigate to previous search result
        function previousSearchResult(toolName) {
            if (searchMatches.length === 0) return;
            
            currentSearchIndex = currentSearchIndex > 0 ? currentSearchIndex - 1 : searchMatches.length - 1;
            scrollToSearchMatch(currentSearchIndex);
            updateSearchCounter(toolName);
        }

        // Update search counter display
        function updateSearchCounter(toolName) {
            const countElement = document.getElementById(toolName + 'SearchCount');
            countElement.textContent = `${currentSearchIndex + 1}/${searchMatches.length}`;
        }

        // Scroll to specific search match
        function scrollToSearchMatch(index) {
            if (searchMatches[index]) {
                const element = document.getElementById(searchMatches[index]);
                if (element) {
                    element.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    // Highlight current match
                    document.querySelectorAll('.search-highlight').forEach(el => el.classList.remove('current-match'));
                    element.classList.add('current-match');
                }
            }
        }

        // Build tree view with search highlighting
        function buildTreeViewWithSearch(data, searchTerm) {
            searchMatches = []; // Reset search matches
            currentSearchIndex = 0; // Reset current index
            let html = '<div class="tree-view-content">';
            html += buildTreeNodeWithSearch(data, '', '', 0, searchTerm);
            html += '</div>';
            return html;
        }

        // Build tree node with search highlighting
        function buildTreeNodeWithSearch(data, key, path, level, searchTerm) {
            const currentPath = path ? (key ? path + '.' + key : path) : key;
            let html = '';
            
            if (data === null) {
                const hasMatch = key && key.toLowerCase().includes(searchTerm);
                const elementId = hasMatch ? 'match-' + searchMatches.length : '';
                if (hasMatch) searchMatches.push(elementId);
                
                html += '<div class="tree-node' + (hasMatch ? ' search-highlight' : '') + '" style="margin-left: ' + (level * 25) + 'px;"' + (elementId ? ' id="' + elementId + '"' : '') + '>';
                if (key) {
                    html += '<span class="tree-key editable-value" data-path="' + currentPath + '" data-editable-key="true" contenteditable="true">"' + highlightText(key, searchTerm) + '"</span>: ';
                }
                html += '<span class="tree-null editable-value" data-path="' + currentPath + '" data-editable-value="true" contenteditable="true">null</span>';
                if (currentPath) {
                    html += '<button class="ml-1 text-[10px] text-emerald-300 hover:text-emerald-100 add-inline" data-insert="after" data-insert-path="' + currentPath + '">＋</button>';
                    html += '<button class="ml-2 text-xs text-rose-300 hover:text-rose-200 delete-btn" data-delete-path="' + currentPath + '">✕</button>';
                }
                html += '</div>';
            } else if (typeof data === 'object') {
                const isArray = Array.isArray(data);
                const entries = isArray ? data : Object.entries(data);
                const count = isArray ? data.length : Object.keys(data).length;
                const nodeId = 'node-' + Math.random().toString(36).substring(2, 11);
                
                // Check if this node or any children match the search
                const hasMatch = searchInObject(data, searchTerm) || (key && key.toLowerCase().includes(searchTerm));
                
                html += '<div class="tree-node" style="margin-left: ' + (level * 25) + 'px;">';
                html += '<span class="tree-toggle" onclick="toggleNode(\'' + nodeId + '\', event)">▼</span>';
                if (key) {
                    html += '<span class="tree-key editable-value" data-path="' + currentPath + '" data-editable-key="true" contenteditable="true">"' + highlightText(key, searchTerm) + '"</span>: ';
                }
                html += '<span class="tree-value">' + (isArray ? '[' : '{') + '</span>';
                html += '<span class="tree-count">' + count + ' ' + (isArray ? 'items' : 'properties') + '</span>';
                html += '<button class="ml-2 text-xs text-emerald-300 hover:text-emerald-200 add-btn" data-add-type="' + (isArray ? 'array' : 'object') + '" data-add-path="' + currentPath + '">＋</button>';
                if (currentPath) html += '<button class="ml-2 text-xs text-rose-300 hover:text-rose-200 delete-btn" data-delete-path="' + currentPath + '">✕</button>';
                html += '</div>';
                
                html += '<div id="' + nodeId + '" class="tree-children' + (hasMatch && searchTerm ? '' : '') + '">';
                if (isArray) {
                    data.forEach((item, index) => {
                        html += buildTreeNodeWithSearch(item, '[' + index + ']', currentPath, level + 1, searchTerm);
                    });
                } else {
                    Object.entries(data).forEach(([k, v]) => {
                        html += buildTreeNodeWithSearch(v, k, currentPath, level + 1, searchTerm);
                    });
                }
                html += '</div>';
                
                html += '<div class="tree-node" style="margin-left: ' + (level * 25) + 'px;">';
                html += '<span class="tree-value">' + (isArray ? ']' : '}') + '</span>';
                html += '</div>';
            } else if (typeof data === 'string') {
                const hasMatch = (key && key.toLowerCase().includes(searchTerm)) || data.toLowerCase().includes(searchTerm);
                const elementId = hasMatch ? 'match-' + searchMatches.length : '';
                if (hasMatch) searchMatches.push(elementId);
                
                html += '<div class="tree-node' + (hasMatch ? ' search-highlight' : '') + '" style="margin-left: ' + (level * 25) + 'px;"' + (elementId ? ' id="' + elementId + '"' : '') + '>';
                if (key) {
                    html += '<span class="tree-key editable-value" data-path="' + currentPath + '" data-editable-key="true" contenteditable="true">"' + highlightText(key, searchTerm) + '"</span>: ';
                }
                html += '<span class="tree-string editable-value" data-path="' + currentPath + '" data-editable-value="true" contenteditable="true">"' + highlightText(escapeHtml(data), searchTerm) + '"</span>';
                if (currentPath) {
                    html += '<button class="ml-1 text-[10px] text-emerald-300 hover:text-emerald-100 add-inline" data-insert="after" data-insert-path="' + currentPath + '">＋</button>';
                    html += '<button class="ml-2 text-xs text-rose-300 hover:text-rose-200 delete-btn" data-delete-path="' + currentPath + '">✕</button>';
                }
                html += '</div>';
            } else if (typeof data === 'number') {
                const hasMatch = (key && key.toLowerCase().includes(searchTerm)) || data.toString().toLowerCase().includes(searchTerm);
                const elementId = hasMatch ? 'match-' + searchMatches.length : '';
                if (hasMatch) searchMatches.push(elementId);
                
                html += '<div class="tree-node' + (hasMatch ? ' search-highlight' : '') + '" style="margin-left: ' + (level * 25) + 'px;"' + (elementId ? ' id="' + elementId + '"' : '') + '>';
                if (key) {
                    html += '<span class="tree-key editable-value" data-path="' + currentPath + '" data-editable-key="true" contenteditable="true">"' + highlightText(key, searchTerm) + '"</span>: ';
                }
                html += '<span class="tree-number editable-value" data-path="' + currentPath + '" data-editable-value="true" contenteditable="true">' + highlightText(data.toString(), searchTerm) + '</span>';
                if (currentPath) {
                    html += '<button class="ml-1 text-[10px] text-emerald-300 hover:text-emerald-100 add-inline" data-insert="after" data-insert-path="' + currentPath + '">＋</button>';
                    html += '<button class="ml-2 text-xs text-rose-300 hover:text-rose-200 delete-btn" data-delete-path="' + currentPath + '">✕</button>';
                }
                html += '</div>';
            } else if (typeof data === 'boolean') {
                const hasMatch = (key && key.toLowerCase().includes(searchTerm)) || data.toString().toLowerCase().includes(searchTerm);
                const elementId = hasMatch ? 'match-' + searchMatches.length : '';
                if (hasMatch) searchMatches.push(elementId);
                
                html += '<div class="tree-node' + (hasMatch ? ' search-highlight' : '') + '" style="margin-left: ' + (level * 25) + 'px;"' + (elementId ? ' id="' + elementId + '"' : '') + '>';
                if (key) {
                    html += '<span class="tree-key editable-value" data-path="' + currentPath + '" data-editable-key="true" contenteditable="true">"' + highlightText(key, searchTerm) + '"</span>: ';
                }
                html += '<span class="tree-boolean editable-value" data-path="' + currentPath + '" data-editable-value="true" contenteditable="true">' + highlightText(data.toString(), searchTerm) + '</span>';
                if (currentPath) {
                    html += '<button class="ml-1 text-[10px] text-emerald-300 hover:text-emerald-100 add-inline" data-insert="after" data-insert-path="' + currentPath + '">＋</button>';
                    html += '<button class="ml-2 text-xs text-rose-300 hover:text-rose-200 delete-btn" data-delete-path="' + currentPath + '">✕</button>';
                }
                html += '</div>';
            }
            
            return html;
        }

        // Highlight matching text
        function highlightText(text, searchTerm) {
            if (!searchTerm) return text;
            
            const regex = new RegExp('(' + escapeRegex(searchTerm) + ')', 'gi');
            return text.replace(regex, '<span class="highlight">$1</span>');
        }

        function deepClone(obj) {
            if (typeof structuredClone === 'function') return structuredClone(obj);
            return JSON.parse(JSON.stringify(obj));
        }

        function parsePath(path) {
            if (!path) return [];
            const parts = path.split('.').filter(Boolean).map(part => {
                if (part.startsWith('[') && part.endsWith(']')) {
                    const idx = parseInt(part.slice(1, -1), 10);
                    return isNaN(idx) ? part : idx;
                }
                return part;
            });
            if (parts[0] === 'root') parts.shift();
            return parts;
        }

        function getDataRef(toolName) {
            return toolName === 'parser' ? editableParserData : editableSizerData;
        }

        function addProperty(toolName, path, key, value) {
            const data = getDataRef(toolName);
            if (!data) return;
            const parts = parsePath(path);
            let ref = data;
            for (let i = 0; i < parts.length; i++) {
                ref = ref?.[parts[i]];
                if (ref == null) return;
            }
            if (ref && typeof ref === 'object' && !Array.isArray(ref)) {
                ref[key] = value;
            }
        }

        function addArrayItem(toolName, path, value) {
            const data = getDataRef(toolName);
            if (!data) return;
            const parts = parsePath(path);
            let ref = data;
            for (let i = 0; i < parts.length; i++) {
                ref = ref?.[parts[i]];
                if (ref == null) return;
            }
            if (Array.isArray(ref)) {
                ref.push(value);
            }
        }

        function insertObjectSibling(toolName, path, position, newKey, value) {
            const data = getDataRef(toolName);
            if (!data) return;
            const parts = parsePath(path);
            if (parts.length === 0) return;
            const targetKey = parts.pop();
            if (typeof targetKey === 'number') return;
            let ref = data;
            for (let i = 0; i < parts.length; i++) {
                ref = ref?.[parts[i]];
                if (ref == null) return;
            }
            if (ref && typeof ref === 'object' && !Array.isArray(ref)) {
                if (newKey in ref) return; // avoid duplicate keys
                const entries = Object.entries(ref);
                const updated = {};
                entries.forEach(([k, v]) => {
                    if (position === 'before' && k === targetKey) {
                        updated[newKey] = value;
                    }
                    updated[k] = v;
                    if (position === 'after' && k === targetKey) {
                        updated[newKey] = value;
                    }
                });
                Object.keys(ref).forEach(k => delete ref[k]);
                Object.assign(ref, updated);
            }
        }

        function insertArraySibling(toolName, path, position, value) {
            const data = getDataRef(toolName);
            if (!data) return;
            const parts = parsePath(path);
            if (parts.length === 0) return;
            const targetIndex = parts.pop();
            if (typeof targetIndex !== 'number') return;
            let ref = data;
            for (let i = 0; i < parts.length; i++) {
                ref = ref?.[parts[i]];
                if (!Array.isArray(ref) && typeof ref !== 'object') return;
            }
            if (Array.isArray(ref)) {
                const insertAt = position === 'before' ? targetIndex : targetIndex + 1;
                ref.splice(insertAt, 0, value);
            }
        }

        function setValueAtPath(toolName, path, newValue) {
            const data = getDataRef(toolName);
            if (!data) return;
            const parts = parsePath(path);
            if (parts.length === 0) return;
            let ref = data;
            for (let i = 0; i < parts.length - 1; i++) {
                if (ref == null) return;
                ref = ref[parts[i]];
            }
            const last = parts[parts.length - 1];
            if (ref == null) return;
            ref[last] = newValue;
        }

        function deleteAtPath(toolName, path) {
            const data = getDataRef(toolName);
            if (!data) return;
            const parts = parsePath(path);
            if (parts.length === 0) return;
            let ref = data;
            for (let i = 0; i < parts.length - 1; i++) {
                if (ref == null) return;
                ref = ref[parts[i]];
            }
            const last = parts[parts.length - 1];
            if (Array.isArray(ref) && typeof last === 'number') {
                ref.splice(last, 1);
            } else if (ref && typeof ref === 'object') {
                delete ref[last];
            }
        }

        function renameKeyAtPath(toolName, path, newKey) {
            const data = getDataRef(toolName);
            if (!data) return;
            const parts = parsePath(path);
            if (parts.length === 0) return;
            const last = parts.pop();
            if (typeof last === 'number') return; // don't rename array indexes
            if (!newKey || newKey === last) return;
            let ref = data;
            for (let i = 0; i < parts.length; i++) {
                if (ref == null) return;
                ref = ref[parts[i]];
            }
            if (ref && typeof ref === 'object' && !Array.isArray(ref) && last in ref) {
                if (newKey in ref) return; // avoid clobbering existing key
                const entries = Object.entries(ref);
                const updated = {};
                entries.forEach(([k, v]) => {
                    const targetKey = k === last ? newKey : k;
                    updated[targetKey] = v;
                });
                Object.keys(ref).forEach(k => delete ref[k]);
                Object.assign(ref, updated); // preserves original order with renamed slot
            }
        }

        function normalizeValue(text) {
            const trimmed = text.trim();
            // Remove surrounding quotes if present (since we render strings with quotes)
            const unquoted = (trimmed.startsWith('"') && trimmed.endsWith('"')) ? trimmed.slice(1, -1) : trimmed;
            // Try JSON parse to preserve numbers/booleans/null/objects/arrays
            try {
                return JSON.parse(trimmed);
            } catch (_) {
                try {
                    return JSON.parse(unquoted);
                } catch (_) {
                    return unquoted;
                }
            }
        }

        function promptForValue() {
            const type = prompt('Type de valeur ? (chaîne, nombre, booléen, null, objet, tableau, json)', 'json');
            if (type === null) return { cancelled: true };
            const t = type.trim().toLowerCase();

            if (t === 'object' || t === 'objet') return { value: {} };
            if (t === 'array' || t === 'tableau' || t === 'liste') return { value: [] };
            if (t === 'null') return { value: null };
            if (t === 'string' || t === 'texte' || t === 'chaine' || t === 'chaîne') {
                const rawText = prompt('Texte ?', '');
                if (rawText === null) return { cancelled: true };
                return { value: rawText };
            }
            if (t === 'boolean' || t === 'bool' || t === 'booléen') {
                const raw = prompt('Valeur booléenne ? (true/false)', 'true');
                if (raw === null) return { cancelled: true };
                return { value: /^true$/i.test(raw.trim()) };
            }
            if (t === 'number' || t === 'nombre' || t === 'numérique') {
                const raw = prompt('Valeur numérique ?', '0');
                if (raw === null) return { cancelled: true };
                const num = Number(raw);
                if (Number.isNaN(num)) {
                    alert('Valeur numérique invalide.');
                    return { cancelled: true };
                }
                return { value: num };
            }
            const raw = prompt('Valeur (JSON ou texte) ?', 'null');
            if (raw === null) return { cancelled: true };
            return { value: normalizeValue(raw) };
        }

        function rerenderTool(toolName) {
            const dataRef = toolName === 'parser' ? editableParserData : editableSizerData;
            if (!dataRef) return;
            const output = document.getElementById(toolName + 'Output');
            const isSizer = toolName === 'sizer';
            const allowEdit = !isSizer;
            const totalSize = getByteSize(JSON.stringify(dataRef));
            const treeHtml = buildTreeView(dataRef, '', isSizer, totalSize, allowEdit);
            const info = isSizer ? '<div class="info-message">Taille actuelle (lecture seule): <strong>' + totalSize + ' bytes</strong> (' + (totalSize / 1024).toFixed(2) + ' KB)</div>' : '';
            output.innerHTML = info + treeHtml;
            if (allowEdit) attachEditableHandlers(toolName);
        }

        function attachEditableHandlers(toolName) {
            if (toolName === 'sizer') return;
            const output = document.getElementById(toolName + 'Output');
            if (!output) return;

            output.querySelectorAll('[data-editable-key="true"]').forEach(span => {
                const node = span.closest('.tree-node');
                span.addEventListener('focus', () => {
                    isEditing = true;
                    node && node.classList.add('editing');
                });
                span.addEventListener('blur', () => {
                    setTimeout(() => {
                        isEditing = false;
                        node && node.classList.remove('editing');
                    }, 80);
                    const path = span.getAttribute('data-path');
                    if (!path) return;
                    const parts = parsePath(path);
                    const oldKey = parts.length ? parts[parts.length - 1] : '';
                    const raw = span.textContent || '';
                    const newKey = raw.replace(/^"|"$/g, '').trim();
                    if (!newKey) {
                        span.textContent = '"' + oldKey + '"';
                        return rerenderTool(toolName);
                    }
                    if (newKey === oldKey) return rerenderTool(toolName);
                    renameKeyAtPath(toolName, path, newKey);
                    rerenderTool(toolName);
                });
            });

            output.querySelectorAll('[data-editable-value="true"]').forEach(span => {
                const node = span.closest('.tree-node');
                span.addEventListener('focus', () => {
                    isEditing = true;
                    node && node.classList.add('editing');
                });
                span.addEventListener('blur', () => {
                    setTimeout(() => {
                        isEditing = false;
                        node && node.classList.remove('editing');
                    }, 80);
                    const path = span.getAttribute('data-path');
                    if (!path) return;
                    const val = normalizeValue(span.textContent || '');
                    setValueAtPath(toolName, path, val);
                    rerenderTool(toolName);
                });
            });

            output.querySelectorAll('[data-delete-path]').forEach(btn => {
                btn.addEventListener('mousedown', (e) => {
                    const active = document.activeElement;
                    const node = btn.closest('.tree-node');
                    if (isEditing || (active && active.isContentEditable) || (node && node.classList.contains('editing'))) {
                        e.preventDefault();
                        e.stopPropagation();
                    }
                });
                btn.addEventListener('click', (e) => {
                    const node = btn.closest('.tree-node');
                    if (isEditing || (node && node.classList.contains('editing'))) {
                        e.preventDefault();
                        e.stopPropagation();
                        return;
                    }
                    const path = btn.getAttribute('data-delete-path');
                    deleteAtPath(toolName, path);
                    rerenderTool(toolName);
                });
            });

            output.querySelectorAll('[data-add-type]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (isEditing) return;
                    const type = btn.getAttribute('data-add-type');
                    const path = btn.getAttribute('data-add-path');
                    if (type === 'object') {
                        const key = prompt('Nom de la nouvelle propriété ?');
                        if (!key) return;
                        const result = promptForValue();
                        if (result.cancelled) return;
                        const val = result.value;
                        addProperty(toolName, path, key, val);
                    } else if (type === 'array') {
                        const result = promptForValue();
                        if (result.cancelled) return;
                        const val = result.value;
                        addArrayItem(toolName, path, val);
                    }
                    rerenderTool(toolName);
                });
            });

            output.querySelectorAll('[data-insert]').forEach(btn => {
                btn.addEventListener('click', () => {
                    if (isEditing) return;
                    const position = btn.getAttribute('data-insert');
                    const path = btn.getAttribute('data-insert-path');
                    const parts = parsePath(path);
                    const last = parts[parts.length - 1];
                    if (typeof last === 'number') {
                        const result = promptForValue();
                        if (result.cancelled) return;
                        const val = result.value;
                        insertArraySibling(toolName, path, position, val);
                    } else {
                        const key = prompt('Nom de la nouvelle propriété ?');
                        if (!key) return;
                        const result = promptForValue();
                        if (result.cancelled) return;
                        const val = result.value;
                        insertObjectSibling(toolName, path, position, key, val);
                    }
                    rerenderTool(toolName);
                });
            });
        }

        // Check if object contains search term
        function searchInObject(obj, searchTerm) {
            if (!searchTerm) return false;
            
            if (typeof obj === 'string') {
                return obj.toLowerCase().includes(searchTerm);
            } else if (typeof obj === 'number' || typeof obj === 'boolean') {
                return obj.toString().toLowerCase().includes(searchTerm);
            } else if (Array.isArray(obj)) {
                return obj.some(item => searchInObject(item, searchTerm));
            } else if (typeof obj === 'object' && obj !== null) {
                return Object.entries(obj).some(([key, value]) => 
                    key.toLowerCase().includes(searchTerm) || searchInObject(value, searchTerm)
                );
            }
            
            return false;
        }

        // Escape HTML
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Escape regex special characters
        function escapeRegex(text) {
            return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }

        // Process Sizer Helper
        function processSizer() {
            const input = document.getElementById('sizerInput').value.trim();
            const output = document.getElementById('sizerOutput');
            
            if (!input) {
                output.innerHTML = '<div class="error-message">Please provide JSON input</div>';
                return;
            }
            
            try {
                sizerData = JSON.parse(input);
                editableSizerData = deepClone(sizerData);
                const totalSize = getByteSize(JSON.stringify(editableSizerData));
                const treeHtml = buildTreeView(editableSizerData, '', true, totalSize, false);
                output.innerHTML = '<div class="info-message">Taille actuelle (lecture seule): <strong>' + totalSize + ' bytes</strong> (' + (totalSize / 1024).toFixed(2) + ' KB)</div>' + treeHtml;
            } catch (e) {
                output.innerHTML = '<div class="error-message">Invalid JSON: ' + e.message + '</div>';
            }
        }

        // Process Diff Tool
        function processDiff() {
            const input1 = document.getElementById('diff1Input').value.trim();
            const input2 = document.getElementById('diff2Input').value.trim();
            const output = document.getElementById('diffOutput');
            
            if (!input1 || !input2) {
                output.innerHTML = '<div class="error-message">Please provide both JSON inputs</div>';
                return;
            }
            
            try {
                const json1 = JSON.parse(input1);
                const json2 = JSON.parse(input2);
                
                const diff = compareJSON(json1, json2);
                output.innerHTML = buildDiffView(diff);
            } catch (e) {
                output.innerHTML = '<div class="error-message">Invalid JSON: ' + e.message + '</div>';
            }
        }

        // Compare two JSON objects
        function compareJSON(obj1, obj2, path = '') {
            const differences = {
                onlyInFirst: [],
                onlyInSecond: [],
                different: []
            };
            
            // Check obj1 keys
            if (typeof obj1 === 'object' && obj1 !== null && typeof obj2 === 'object' && obj2 !== null) {
                const keys1 = Array.isArray(obj1) ? obj1.map((_, i) => i.toString()) : Object.keys(obj1);
                const keys2 = Array.isArray(obj2) ? obj2.map((_, i) => i.toString()) : Object.keys(obj2);
                
                // Find keys only in first object
                keys1.forEach(key => {
                    const currentPath = path ? path + '.' + key : key;
                    
                    if (Array.isArray(obj2) ? (parseInt(key) >= obj2.length) : !(key in obj2)) {
                        differences.onlyInFirst.push({
                            path: currentPath,
                            value: obj1[key]
                        });
                    } else {
                        // Key exists in both, compare values
                        const val1 = obj1[key];
                        const val2 = obj2[key];
                        
                        if (typeof val1 === 'object' && val1 !== null && typeof val2 === 'object' && val2 !== null) {
                            // Recursively compare objects
                            const nestedDiff = compareJSON(val1, val2, currentPath);
                            differences.onlyInFirst.push(...nestedDiff.onlyInFirst);
                            differences.onlyInSecond.push(...nestedDiff.onlyInSecond);
                            differences.different.push(...nestedDiff.different);
                        } else if (JSON.stringify(val1) !== JSON.stringify(val2)) {
                            differences.different.push({
                                path: currentPath,
                                value1: val1,
                                value2: val2
                            });
                        }
                    }
                });
                
                // Find keys only in second object
                keys2.forEach(key => {
                    const currentPath = path ? path + '.' + key : key;
                    
                    if (Array.isArray(obj1) ? (parseInt(key) >= obj1.length) : !(key in obj1)) {
                        differences.onlyInSecond.push({
                            path: currentPath,
                            value: obj2[key]
                        });
                    }
                });
            } else if (JSON.stringify(obj1) !== JSON.stringify(obj2)) {
                differences.different.push({
                    path: path || 'root',
                    value1: obj1,
                    value2: obj2
                });
            }
            
            return differences;
        }

        // Build diff view
        function buildDiffView(diff) {
            let html = '';
            
            if (diff.onlyInFirst.length === 0 && diff.onlyInSecond.length === 0 && diff.different.length === 0) {
                return '<div class="success-message">✓ Both JSON objects are identical!</div>';
            }
            
            html += '<div class="diff-container">';
            
            // Left panel - Missing in second
            html += '<div class="diff-panel">';
            html += '<h3>Missing in Second JSON (Present only in First)</h3>';
            if (diff.onlyInFirst.length > 0) {
                diff.onlyInFirst.forEach(item => {
                    html += '<div class="diff-removed">';
                    html += '<strong>' + escapeHtml(item.path) + '</strong>: ';
                    html += '<span>' + escapeHtml(JSON.stringify(item.value, null, 2)) + '</span>';
                    html += '</div>';
                });
            } else {
                html += '<div class="info-message">No missing elements</div>';
            }
            html += '</div>';
            
            // Right panel - Missing in first
            html += '<div class="diff-panel">';
            html += '<h3>Missing in First JSON (Present only in Second)</h3>';
            if (diff.onlyInSecond.length > 0) {
                diff.onlyInSecond.forEach(item => {
                    html += '<div class="diff-added">';
                    html += '<strong>' + escapeHtml(item.path) + '</strong>: ';
                    html += '<span>' + escapeHtml(JSON.stringify(item.value, null, 2)) + '</span>';
                    html += '</div>';
                });
            } else {
                html += '<div class="info-message">No missing elements</div>';
            }
            html += '</div>';
            
            html += '</div>';
            
            // Different values section
            if (diff.different.length > 0) {
                html += '<div style="margin-top: 20px;">';
                html += '<h3>Different Values</h3>';
                html += '<div class="diff-panel">';
                diff.different.forEach(item => {
                    html += '<div class="diff-modified">';
                    html += '<strong>' + escapeHtml(item.path) + '</strong><br>';
                    html += '<span style="color: #dc3545;">First: ' + escapeHtml(JSON.stringify(item.value1, null, 2)) + '</span><br>';
                    html += '<span style="color: #28a745;">Second: ' + escapeHtml(JSON.stringify(item.value2, null, 2)) + '</span>';
                    html += '</div>';
                });
                html += '</div>';
                html += '</div>';
            }
            
            return html;
        }

        // Toggle maximized view for tree view
        function toggleFullscreen(section) {
            const outputElement = document.getElementById(section + 'Output');
            const isMaximized = outputElement.classList.contains('maximized');
            const btn = document.getElementById(section + 'MaximizeBtn');
            
            if (isMaximized) {
                // Exit maximized mode
                outputElement.classList.remove('maximized');
                document.body.classList.remove('has-maximized-view');
                if (btn) btn.textContent = 'Maximize';
            } else {
                // Enter maximized mode
                
                outputElement.classList.add('maximized');
                document.body.classList.add('has-maximized-view');
                if (btn) btn.textContent = 'Minimize';
                
                // Force visibility
                outputElement.style.display = 'block';
                outputElement.style.visibility = 'visible';
                
                // Add temporary content if empty
                if (!outputElement.innerHTML.trim()) {
                    outputElement.innerHTML = '<div style="padding: 20px; color: #666;">No content to display. Please load and process some JSON first.</div>';
                }
            }
        }
    </script>
</body>
</html>
